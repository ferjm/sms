'use strict';
var kLowResources = false;
var SmartWorkers = {
        handle: function sr_handle(e) {
            return Object.keys(this.resources).some(function (key) {
                if (!kLowResources) {
                    return false;
                }
                if (e.request.url.contains(key)) {
                    var resource = this.resources[key];
                    e.respondWith(new Promise(function (resolve, reject) {
                        var code = '(function() {' + '  var scope = new Proxy(' + '    {},' + '    new WorkerSandbox("' + e.request.url + '"));' + '' + '  (function() {' + '    with(scope) {' + '      "use strict";' + '      (function() {' + '        ' + resource.content + '      }).call(this);' + '    }' + '  }).call(scope);' + '})();';
                        resolve(new Response(code, resource.opts));
                    }));
                    return true;
                }
                return false;
            }, this);
        },
        resources: {
            '/app/js/update/worker_api.js': {
                content: '\'use strict\';\n\n\'use strict\';\n\n// IPDLProtocol is designed to create a point-to-point communication\n// mechanism.\n// This communication can happens between 2 windows, 2 workers, or a\n// window and worker.\n//\n// An simple example to use it would be:\n//\n//  ****************\n//  * PUpdate.ipdl *\n//  ****************\n//  protocol PUpdate\n//  {\n//    worker:\n//      CheckForUpdate();\n//      ApplyUpdate(updateUrl);\n//\n//    window:\n//  };\n//\n//  *************\n//  * window.js *\n//  *************\n//  var worker = new Worker(\'worker.js\');\n//  var protocol = new IPDLProtocol(\'update\', worker);\n//\n//  protocol.sendCheckForUpdate().then(\n//    function success(rv) {\n//      // do something with the result.\n//    ),\n//\n//    function error(rv) {\n//      // do something with the result.\n//    }\n//  );\n//\n//  protocol.sendApplyUpdate(updateUrl).then(\n//    function success(rv) {\n//      // do something with the result.\n//    },\n//\n//    function error(rv) {\n//      // do something with the result.\n//    }\n//  );\n//\n//  *************\n//  * worker.js *\n//  *************\n//  var protocol = new IPDLProtocol(\'update\');\n//\n//  protocol.recvCheckForUpdate = function(resolve, reject, args) {\n//    var xhr = new XMLHttpRequest();\n//    xhr.open(\'GET\', kServerUrl, true);\n//    xhr.send();\n//    xhr.onload = function() {\n//      resolve(this.responseText);\n//    };\n//    \n//    xhr.onerror = function() {\n//      reject(this.status);\n//    };\n//  };\n//\n//  protocol.recvApplyUpdate = function(resolve, reject, args) {\n//    applyUpdate(args.updateUrl).then(\n//      function success(rv) {\n//        resolve(rv);\n//      },\n//\n//      function error(rv) {\n//        reject(rv);\n//      }\n//    );\n//  };\n//  \n\n\'use strict\';\n\n/* parser generated by jison 0.4.15 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a \'hash\' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,13],$V1=[1,12],$V2=[10,12,14],$V3=[1,23],$V4=[1,24],$V5=[1,36],$V6=[1,40];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {"error":2,"ipdl":3,"protocol":4,"EOF":5,"PROTOCOL":6,"NAME":7,"{":8,"protocol_sides":9,"}":10,";":11,"DEBUG":12,"protocol_side":13,"SIDE":14,":":15,"protocol_methods":16,"protocol_method":17,"(":18,")":19,"protocol_parameters":20,"PROMISE":21,"<":22,"protocol_returns":23,">":24,"protocol_return_name":25,",":26,"protocol_parameter_name":27,"$accept":0,"$end":1},\nterminals_: {2:"error",5:"EOF",6:"PROTOCOL",7:"NAME",8:"{",10:"}",11:";",12:"DEBUG",14:"SIDE",15:":",18:"(",19:")",21:"PROMISE",22:"<",24:">",26:","},\nproductions_: [0,[3,2],[4,6],[4,7],[9,1],[9,2],[13,2],[13,3],[13,3],[13,4],[16,2],[16,3],[17,3],[17,4],[17,5],[17,4],[23,1],[23,3],[25,1],[20,1],[20,3],[27,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $.length - 1;\nswitch (yystate) {\ncase 1:\n\n    protocols = $[$0-1];\n    debug(protocols.toString());\n    this.$ = $[$0-1];\n  \nbreak;\ncase 2:\n\n    this.$ = new Protocol($[$0-4], $[$0-2]);\n  \nbreak;\ncase 3:\n\n    this.$ = new DebugProtocol($[$0-4], $[$0-2]);\n  \nbreak;\ncase 4: case 16: case 19:\n\n    this.$ = [$[$0]];\n  \nbreak;\ncase 5:\n\n    this.$ = aggregate($[$0], $[$0-1]);\n  \nbreak;\ncase 6:\n\n    this.$ = new Side($[$0-1], []);\n  \nbreak;\ncase 7:\n\n    this.$ = new DebugSide($[$0-1], []);\n  \nbreak;\ncase 8:\n\n    this.$ = new Side($[$0-2], $[$0]);\n  \nbreak;\ncase 9:\n\n    this.$ = new DebugSide($[$0-2], $[$0]);\n  \nbreak;\ncase 10:\n\n    this.$ = [$[$0-1]];\n  \nbreak;\ncase 11: case 17: case 20:\n\n    this.$ = aggregate($[$0-2], $[$0]);\n  \nbreak;\ncase 12:\n\n    this.$ = new Method($[$0-2], []);\n  \nbreak;\ncase 13:\n\n    this.$ = new Method($[$0-3], $[$0-1]);\n  \nbreak;\ncase 14:\n\n    this.$ = new ReturnMethod($[$0], $[$0-2]);\n  \nbreak;\ncase 15:\n\n    this.$ = new ReturnMethod($[$0], []);\n  \nbreak;\ncase 18:\n\n    this.$ = new Return($[$0]);\n  \nbreak;\ncase 21:\n\n    this.$ = new Parameter($[$0]);\n  \nbreak;\n}\n},\ntable: [{3:1,4:2,6:[1,3],12:[1,4]},{1:[3]},{5:[1,5]},{7:[1,6]},{6:[1,7]},{1:[2,1]},{8:[1,8]},{7:[1,9]},{9:10,12:$V0,13:11,14:$V1},{8:[1,14]},{10:[1,15],12:$V0,13:16,14:$V1},o($V2,[2,4]),{15:[1,17]},{14:[1,18]},{9:19,12:$V0,13:11,14:$V1},{11:[1,20]},o($V2,[2,5]),o($V2,[2,6],{16:21,17:22,7:$V3,21:$V4}),{15:[1,25]},{10:[1,26],12:$V0,13:16,14:$V1},{5:[2,2]},o($V2,[2,8]),{11:[1,27]},{18:[1,28]},{22:[1,29]},o($V2,[2,7],{17:22,16:30,7:$V3,21:$V4}),{11:[1,31]},o($V2,[2,10],{17:22,16:32,7:$V3,21:$V4}),{7:$V5,19:[1,33],20:34,27:35},{7:$V6,23:37,24:[1,38],25:39},o($V2,[2,9]),{5:[2,3]},o($V2,[2,11]),{11:[2,12]},{19:[1,41]},{19:[2,19],26:[1,42]},o([19,26],[2,21]),{24:[1,43]},{7:$V3,17:44,21:$V4},{24:[2,16],26:[1,45]},o([24,26],[2,18]),{11:[2,13]},{7:$V5,20:46,27:35},{7:$V3,17:47,21:$V4},{11:[2,15]},{7:$V6,23:48,25:39},{19:[2,20]},{11:[2,14]},{24:[2,17]}],\ndefaultActions: {5:[2,1],20:[2,2],31:[2,3],33:[2,12],41:[2,13],44:[2,15],46:[2,20],47:[2,14],48:[2,17]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        throw new Error(str);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = \'\', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == \'undefined\') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === \'function\') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n        function lex() {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== \'number\') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        }\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == \'undefined\') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === \'undefined\' || !action.length || !action[0]) {\n                var errStr = \'\';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push(\'\\\'\' + this.terminals_[p] + \'\\\'\');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = \'Parse error on line \' + (yylineno + 1) + \':\\n\' + lexer.showPosition() + \'\\nExpecting \' + expected.join(\', \') + \', got \\\'\' + (this.terminals_[symbol] || symbol) + \'\\\'\';\n                } else {\n                    errStr = \'Parse error on line \' + (yylineno + 1) + \': Unexpected \' + (symbol == EOF ? \'end of input\' : \'\\\'\' + (this.terminals_[symbol] || symbol) + \'\\\'\');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error(\'Parse Error: multiple actions possible at state: \' + state + \', token: \' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== \'undefined\') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n\n  var protocols = null;\n  function debug(str) {\n    console.log(str);\n  }\n\n  function error(str) {\n    var output = \'\\x1b[31m\' + str + \'\\x1b[0m\';\n    console.log(output);\n\n    throw new Error(str);\n  }\n\n  function aggregate(value, rv) {\n    var results = [value];\n    for (var i = 0; i < rv.length; i++) {\n      results.push(rv[i]);\n    }\n\n    return results;\n  }\n\n  function uppercase(name) {\n    return name.charAt(0).toUpperCase() + name.slice(1)\n  }\n\n  function DebugProtocol(name, sides) {\n    var protocol = new Protocol(name, sides);\n    protocol.debug = true;\n    return protocol;\n  }\n\n  function Protocol(name, sides) {\n    if (name[0] !== \'P\') {\n      error(\'The protocol name should start with a \\\'P\\\'\');\n    }\n\n    if (name === \'P\') {\n      error(\'The protocol name can not just be \\\'P\\\'\');\n    }\n\n    this.name = name;\n    this.sides = sides;\n    sides.forEach(function(side) {\n      if (side === \'both\') {\n        return;\n      }\n\n      side.binding = this.generateBindingFor(side);\n    }, this);\n  }\n\n  Protocol.prototype.generateBindingFor = function(targetSide) {\n    function recv(reject, resolve, args) {};\n\n    function send(name, args) {\n      return /* Promise */ this._call(name, args);\n    };\n\n    var binding = {};\n\n    this.sides.forEach(function(side) {\n      var oppositeSide = (side.name !== targetSide.name);\n\n      side.methods.forEach(function(method) {\n        var name = uppercase(method.name);\n\n        if (!oppositeSide || side.name === \'both\') {\n          binding[\'recv\' + name] = recv;\n        }\n\n        if (oppositeSide || side.name === \'both\') {\n\n          binding[\'send\' + name] = function() {\n            var args = Array.prototype.slice.call(arguments);\n\n            var parameters = {};\n            method.parameters.forEach(function(parameter) {\n              parameters[parameter.name] = args.shift();\n            });\n\n            return send.call(this, name, parameters);\n          }\n        }\n      });\n    });\n\n    return binding;\n  };\n\n  Protocol.prototype.toString = function() {\n    var str = \'\';\n    if (this.debug) {\n      str += \'DebugProtocol: \';\n    } else {\n      str += \'Protocol: \';\n    }\n\n    str += this.name + \'\\n\';\n\n    this.sides.forEach(function(side) {\n      if (side.debug) {\n        str += \'  DebugSide: \';\n      } else {\n        str += \'  Side: \';\n      }\n      str += side.name + \'\\n\';\n\n      side.methods.forEach(function(method) {\n        str += \'    method: \' + method.name + \'\\n\';\n\n        method.parameters.forEach(function(parameter) {\n          str += \'      parameter: \' + parameter.name + \'\\n\';\n        });\n\n        method.returns.forEach(function(rv) {\n          str += \'      return: \' + rv.name + \'\\n\';\n        });\n      });\n    });\n\n    this.sides.forEach(function(side) {\n      str += \'\\n--- \' + side.name + \' Side ---\\n\';\n      for (var method in this[side.name]) {\n        str += \'  \' + method + \': \' + this[side.name][method] + \'\\n\';\n      }\n    }, this);\n\n    return str;\n  };\n\n  function DebugReturnMethod(method, returns) {\n    var returnMethod = new ReturnMethod(method, returns);\n    returnMethod.debug = true;\n    return returnMethod;\n  }\n\n  function ReturnMethod(method, returns) {\n    this.type = \'method\';\n    this.name = method.name;\n    this.parameters = method.parameters;\n    this.returns = returns;\n  }\n\n  function DebugMethod(name, parameters) {\n    var method = new Method(name, parameters);\n    method.debug = true;\n    return method;\n  }\n\n  function Method(name, parameters) {\n    this.type = \'method\';\n    this.name = name;\n    this.parameters = parameters;\n    this.returns = [];\n  }\n\n  function Parameter(name) {\n    this.type = \'parameter\';\n    this.name = name;\n  }\n\n  function Return(name) {\n    this.type = \'return\';\n    this.name = name;\n  }\n\n  function DebugSide(name, methods) {\n    var side = new Side(name, methods);\n    side.debug = true;\n    return side;\n  }\n\n  function Side(name, methods) {\n    this.type = \'side\';\n    this.name = name;\n    this.methods = methods;\n  }\n\n\nvar oldParser = parser.parse;\nparser.parse = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var rv = oldParser.apply(parser, args);\n  return protocols || null;\n}\n\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = \'\';\n        this.conditionStack = [\'INITIAL\'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError(\'Lexical error on line \' + (this.yylineno + 1) + \'. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\' + this.showPosition(), {\n                text: "",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? \'...\':\'\') + past.substr(-20).replace(/\\n/g, "");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? \'...\' : \'\')).replace(/\\n/g, "");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join("-");\n        return pre + this.upcomingInput() + "\\n" + c + "^";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = \'\';\n            this.match = \'\';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === "") {\n            return this.EOF;\n        } else {\n            return this.parseError(\'Lexical error on line \' + (this.yylineno + 1) + \'. Unrecognized text.\\n\' + this.showPosition(), {\n                text: "",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions["INITIAL"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return "INITIAL";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:/* skip characters */\nbreak;\ncase 1:/* skip comments */\nbreak;\ncase 2:return 6\nbreak;\ncase 3:return 21\nbreak;\ncase 4:return 14\nbreak;\ncase 5:return 12\nbreak;\ncase 6:return 7\nbreak;\ncase 7:return 8\nbreak;\ncase 8:return 10\nbreak;\ncase 9:return 18\nbreak;\ncase 10:return 19\nbreak;\ncase 11:return 22\nbreak;\ncase 12:return 24\nbreak;\ncase 13:return 15\nbreak;\ncase 14:return 11\nbreak;\ncase 15:return 26\nbreak;\ncase 16:return 5\nbreak;\n}\n},\nrules: [/^(?:\\s+)/,/^(?:(\\/\\*(.|\\r|\\n)*?\\*\\/))/,/^(?:protocol\\b)/,/^(?:Promise\\b)/,/^(?:((window\\b)|(worker\\b)|(serviceworker\\b)|(both\\b)))/,/^(?:(debug\\b))/,/^(?:[a-zA-Z]+)/,/^(?:\\{)/,/^(?:\\})/,/^(?:\\()/,/^(?:\\))/,/^(?:<)/,/^(?:>)/,/^(?::)/,/^(?:;)/,/^(?:,)/,/^(?:$)/],\nconditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],"inclusive":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== \'undefined\' && typeof exports !== \'undefined\') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function commonjsMain(args) {\n    if (!args[1]) {\n        console.log(\'Usage: \'+args[0]+\' FILE\');\n        process.exit(1);\n    }\n    var source = require(\'fs\').readFileSync(require(\'path\').normalize(args[1]), "utf8");\n    return exports.parser.parse(source);\n};\nif (typeof module !== \'undefined\' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}\n;\n\nfunction IPDL(name) {\n  var ast = parser.parse(this._getFileContent(name));\n  this.side = this.getSide(ast.sides);\n  this.otherside = this.getOtherSide(ast.sides);\n  this.debug = ast.debug;\n\n  Object.freeze(this);\n}\n\nIPDL.prototype.getSide = function(sides) {\n  // XXX This is very weak...\n  var sideName = \'\';\n\n  if (sideName === \'\') {\n    try {\n      window;\n      // XXX This stuff does not throw in our smartworker.\n      // Needs to understand the diff.\n      if (window !== undefined) {\n        sideName = \'window\';\n      }\n    } catch(e) {}\n  }\n\n  if (sideName === \'\') {\n    try {\n      postMessage;\n      sideName = \'worker\';\n    } catch(e) {}\n  }\n\n  if (sideName === \'\') {\n    sideName = \'serviceworker\';\n  }\n\n  return sides.find(function(side) {\n    return sideName == side.name;\n  }, this);\n};\n\nIPDL.prototype.getOtherSide = function(sides) {\n  return sides.find(function(side) {\n    return this.side.name != side.name;\n  }, this);\n};\n\nIPDL.prototype._getFileContent = function(name) {\n  var xhr = new XMLHttpRequest();\n  var filename =\n    \'/sms/app/js/protocols/ipdl/\' +\n    \'P\' +\n    name.charAt(0).toUpperCase() + name.slice(1) +\n    \'.ipdl\';\n\n  xhr.open(\'GET\', filename, false);\n  xhr.send();\n\n  return xhr.responseText;\n};\n\n;\n\'use strict\';\n\nvar BridgeHelper = {\n  map: {\n    \'window->worker\': BridgeWindowToWorker,\n    \'worker->window\': BridgeWorkerToWindow,\n    \'window->serviceworker\': BridgeWindowToServiceWorker,\n    \'serviceworker->window\': BridgeServiceWorkerToWindow\n  },\n\n  createNewBridge: function bh_createNewBridge(tag, ipdl, target) {\n    if (!tag) {\n      throw new Error(\'Bridge needs a tag.\');\n    }\n\n    if (!ipdl) {\n      throw new Error(\'Bridge needs an ipdl description.\');\n    }\n\n    var direction = ipdl.side.name + \'->\' + ipdl.otherside.name;\n    var bridge = this.map[direction];\n    if (!bridge) {\n      throw new Error(\'Bridge for \' +\n                      direction +\n                      \' is not implemented.\');\n    }\n\n    return new bridge(tag, ipdl, target);\n  }\n};\n\n/**\n * Bridge\n */\nfunction Bridge(tag, ipdl, target) {\n  debug(\n    \'Creating a bridge for \' +\n    ipdl.side.name + \'->\' + ipdl.otherside.name +\n    \' for \' +\n    target +\n    \' (\' + tag + \')\'\n  );\n\n  this.tag = tag;\n  this.ipdl = ipdl;\n  this.target = target;\n  this.debug = this.ipdl.debug || this.ipdl.side.debug;\n\n  this.listenMessage();\n\n  this.recvMessage = Bridge.prototype.recvMessage;\n  Object.seal(this);\n}\n\nBridge.prototype = {\n  /**\n   * Needs to be overidden by the class that inherit from Bridge.\n   */\n  listenMessage: function bridge_listenMessage() {\n    throw new Error(\'Not implemented.\');\n  },\n\n  /**\n   * Needs to be overidden by the class that inherit from Bridge.\n   */\n  forwardMessage: function bridge_forwardMessage() {\n    throw new Error(\'Not implemented.\');\n  },\n\n  /**\n   * Needs to be overidden by the consumer of the bridge.\n   */\n  recvMessage: function bridge_recvMessage() {\n    throw new Error(\'Not implemented.\');\n  },\n\n  handleEvent: function bridge_handleEvent(e) {\n    var json = e.data;\n    if (!this.checkMessage(json)) {\n      return;\n    }\n\n    this.dump(json, true);\n\n    this.recvMessage(json);\n  },\n\n  postMessage: function bridge_postMessage(json) {\n    if (!this.checkMessage(json)) {\n      return;\n    }\n\n    this.dump(json);\n\n    this.forwardMessage(json);\n  },\n\n  checkMessage: function bridge_checkMessage(json) {\n    if (!json) {\n      throw new Error(\'Message data is empty.\');\n    }\n\n    if (!\'tag\' in json) {\n      throw new Error(\'Message does not have a tag.\');\n    }\n\n    if (!\'uuid\' in json) {\n      throw new Error(\'Message does not have an uuid.\');\n    }\n\n    if (json.tag !== this.tag) {\n      return false;\n    }\n\n    return true;\n  },\n\n  dump: function bridge_dump(json, revert) {\n    if (this.debug) {\n      var direction = revert ?\n        this.ipdl.otherside.name + \'->\' + this.ipdl.side.name :\n        this.ipdl.side.name + \'->\' + this.ipdl.otherside.name;\n\n      debug(\'[\' + this.tag + \'] \' + direction);\n      for (var prop in json) {\n        debug(prop + \': \' + json[prop]);\n      }\n    }\n  }\n};\n\n\n/**\n * BridgeWindowToWorker\n */\nfunction BridgeWindowToWorker(tag, ipdl, target) {\n  Bridge.call(this, tag, ipdl, target);\n\n  if (!this.target) {\n    var msg = \'Need an explicit target for a \' +\n              this.side.name +\n              \'->\' +\n              this.otherside.name +\n              \' bridge.\';\n    throw new Error(msg);\n  }\n}\n\nBridgeWindowToWorker.prototype = Object.create(Bridge.prototype);\n\nBridgeWindowToWorker.prototype.listenMessage = function() {\n  this.target.addEventListener(\'message\', this);\n};\n\nBridgeWindowToWorker.prototype.forwardMessage = function(json) {\n  this.target.postMessage(json);\n};\n\n/**\n * BridgeWindowToServiceWorker\n */\nfunction BridgeWindowToServiceWorker(tag, ipdl, target) {\n  Bridge.call(this, tag, ipdl, target || navigator.serviceWorker.controller);\n\n  if (!this.target) {\n    var msg = \'Need an explicit target for a \' +\n              this.side.name +\n              \'->\' +\n              this.otherside.name +\n              \' bridge if the page is not controlled.\';\n    throw new Error(msg);\n  }\n}\n\nBridgeWindowToServiceWorker.prototype = Object.create(Bridge.prototype);\n\nBridgeWindowToServiceWorker.prototype.listenMessage = function() {\n  addEventListener(\'message\', this);\n};\n\nBridgeWindowToServiceWorker.prototype.forwardMessage = function(json) {\n  this.target.postMessage(json);\n};\n\n\n/**\n * BridgeWorkerToWindow\n */\nfunction BridgeWorkerToWindow(tag, ipdl, target) {\n  Bridge.call(this, tag, ipdl, target);\n}\n\nBridgeWorkerToWindow.prototype = Object.create(Bridge.prototype);\n\nBridgeWorkerToWindow.prototype.listenMessage = function() {\n  addEventListener(\'message\', this);\n};\n\nBridgeWorkerToWindow.prototype.forwardMessage = function(json) {\n  postMessage(json);\n};\n\n\n/**\n * BridgeServiceWorkerToWindow\n */\nfunction BridgeServiceWorkerToWindow(tag, ipdl, target) {\n  Bridge.call(this, tag, ipdl, target);\n}\n\nBridgeServiceWorkerToWindow.prototype = Object.create(Bridge.prototype);\n\nBridgeServiceWorkerToWindow.prototype.listenMessage = function() {\n  addEventListener(\'message\', this);\n};\n\nBridgeServiceWorkerToWindow.prototype.forwardMessage = function(json) {\n  clients.getAll().then(function(windows) {\n    windows.forEach(function(window) {\n      window.postMessage(json);\n    });\n  });\n};\n\n;\n\'use strict\';\n\n\'use strict\';\n\n\'use strict\';\n\nfunction generateUUID(){\n  var timestamp = Date.now();\n  return \'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\'.replace(\n    /[xy]/g,\n    function onEachCharacter(c) {\n      var r = (timestamp + Math.random() * 16) % 16 | 0;\n      timestamp = Math.floor(timestamp / 16);\n      return (c == \'x\' ? r : (r&0x7|0x8)).toString(16);\n    }\n  );\n};\n;\n\nfunction Message(tag, uuid) {\n  if (!tag) {\n    throw new Error(\'Message: |tag| is required.\');\n  }\n\n  if (!uuid) {\n    throw new Error(\'Message: |uuid| is required.\');\n  }\n\n  this.tag = tag;\n  this.uuid = uuid;\n  this.timestamp = Date.now();\n\n  Object.freeze(this);\n};\n\nfunction CallMessage(tag, method, args) {\n  this.method = method;\n  this.args = args;\n\n  Message.call(this, tag, generateUUID());\n};\n\nfunction SuccessMessage(tag, uuid, rv) {\n  this.rv = rv;\n  this.success = true;\n\n  Message.call(this, tag, uuid);\n};\n\nfunction FailureMessage(tag, uuid, rv) {\n  this.rv = rv;\n  this.success = false;\n\n  Message.call(this, tag, uuid);\n};\n\n;\n\'use strict\';\n\nfunction PromiseStore() {\n  this._queue = {};\n\n  Object.freeze(this);\n}\n\nPromiseStore.prototype.has = function(uuid) {\n  return !!this._queue[uuid];\n};\n\nPromiseStore.prototype.new = function(uuid) {\n  var resolveCallback = null;\n  var rejectCallback = null;\n  var promise = new Promise(function(resolve, reject) {\n    resolveCallback = resolve;\n    rejectCallback = reject;\n  });\n  promise.resolve = resolveCallback;\n  promise.reject = rejectCallback;\n\n  return this._queue[uuid] = promise;\n};\n\nPromiseStore.prototype.delete = function(uuid) {\n  delete this._queue[uuid];\n};\n\nPromiseStore.prototype.get = function(uuid) {\n  return this._queue[uuid];\n};\n\nPromiseStore.prototype.resolve = function(uuid, success, rv) {\n  var promise = this.get(uuid);\n  if (success) {\n    promise.resolve(rv);\n  } else {\n    promise.reject(rv);\n  }\n\n  this.delete(uuid);\n};\n\n;\n\nvar Protocol = function(methods, bridge) {\n  this.store = new PromiseStore();\n\n  this.methods = methods;\n  methods._call = this.onMethodCallBeforeBridge.bind(this);\n\n  this.bridge = bridge;\n  bridge.recvMessage = this.recvBridgeMessage.bind(this);\n\n  Object.freeze(this);\n};\n\nProtocol.prototype.recvBridgeMessage = function(json) {\n  if (\'method\' in json) {\n    this.onMethodCallAfterBridge(json);\n  } else {\n    this.onMethodResolveBeforeBridge(json);\n  }\n};\n\nProtocol.prototype.onMethodCallBeforeBridge = function(method, args) {\n  var msg = new CallMessage(this.bridge.tag, method, args);\n  this.bridge.postMessage(msg);\n\n  return this.store.new(msg.uuid);\n};\n\nProtocol.prototype.onMethodResolveBeforeBridge = function(json) {\n  var uuid = json.uuid;\n  if (!this.store.has(uuid)) {\n    throw new Error(\'There is no promise for method.\');\n  }\n\n  this.store.resolve(uuid, json.success, json.rv);\n};\n\nProtocol.prototype.onMethodCallAfterBridge = function(json) {\n  var methodName = \'recv\' + json.method;\n  if (!methodName in this.methods) {\n    throw new Error(\'Method \' + methodName + \' does not exists.\');\n  }\n\n  this.methods[methodName](\n    this.onMethodResolveAfterBridge.bind(this, json.uuid),\n    this.onMethodRejectAfterBridge.bind(this, json.uuid),\n    json.args\n  );\n};\n\nProtocol.prototype.onMethodResolveAfterBridge = function(uuid, rv) {\n  var msg = new SuccessMessage(this.bridge.tag, uuid, rv);\n  this.bridge.postMessage(msg);\n};\n\nProtocol.prototype.onMethodRejectAfterBridge = function(uuid, rv) {\n  var msg = new FailureMessage(this.bridge.tag, uuid, rv);\n  this.bridge.postMessage(msg);\n};\n\n;\n\nvar IPDLProtocol = function(name, target) {\n  var ipdl = new IPDL(name);\n  var bridge = BridgeHelper.createNewBridge(name, ipdl, target);\n  var protocol = new Protocol(ipdl.side.binding, bridge);\n\n  return ipdl.side.binding;\n};\n\n;\n\'use strict\';\n\n// UpdateUtils take a update url which point to an update file format.\n// Ideally this patch format will be a intermediate representation\n// of the logical operations that should applies on a per file basis.\n//\n// The intermediate representation is designed to be as small\n// as possible, while easily readable/extendable.\n//\n// This is a json file following the rules:\n// {\n//   "absolute_file_path_1": [\n//     0: some_binary_diff,\n//     -1: "line content to delete at line 1",\n//     2: "line content to add at line 2"\n//   },\n//   "absolute_file_path_2": {\n//     ...\n//   }\n// }\n//\n// TODO Ensure unified diffs follows the defined format for\n//      intermediate representation.\n//      Also IIRC iterating on an object does not guarantee the\n//      ordering, which will means the format should be a little\n//      bit more complex in this case (or maybe not a json object).\n//\n// For the moment, UpdateUtils supports only unified diff format.\n// Once more format would be supported it would be nice to have\n// a file format detector, in order to load and use only the\n// correct format parser.\n//\n\n\'use strict\';\n\n// UnifiedDiff converts a unified diff patch format into an\n// intermediate representation (called ir).\n//\n// This intermediate representation is here to abstract the update\n// format from updates on the content, and let us change the update\n// backend in the future.\n//\n// TODO Parse the first word of each line, instead of multiple regexp.\n//      This will support more random keywords.\n\nvar UnifiedDiff = {\n  parse: function(text) {\n    var ir = {};\n\n    var lines = text.split(\'\\n\');\n\n    var nop = function(str) {\n      return str;\n    };\n\n    var kSchemas = [\n      [/^diff\\s/, addFile],\n      [/^new file mode \\d+$/, nop],\n      [/^index\\s[\\da-zA-Z]+\\.\\.[\\da-zA-Z]+(\\s(\\d+))?$/, nop],\n      [/^---\\s/, nop],\n      [/^\\+\\+\\+\\s/, nop],\n      [/^@@/, addHunk],\n      [/^-/, addDeletion],\n      [/^\\+/, addAddition],\n      [/^From\\s/, nop],\n      [/^Date\\s/, nop],\n      [/^Subject\\s/, nop],\n      [/^---$/, nop]\n    ];\n\n    function parse(line) {\n      for (var i = 0; i < kSchemas.length; i++) {\n        var schema = kSchemas[i];\n        if (line.match(schema[0])) {\n          schema[1](line);\n          return;\n        }\n      };\n\n      increment();\n    };\n\n    var files = {};\n    var currentFilename = \'\';\n    var currentPosition = 0;\n\n    lines.forEach(function onEachLine(line) {\n      parse(line) + \'\\n\';\n    });\n\n    for (var file in files) {\n      //console.log(file);\n\n      var operations = files[file].operations;\n      operations.forEach(function onEachOperation(op) {\n        if (op.type == \'deletion\') {\n          //console.log(\'delete line \' + Math.abs(op.lineNumber));\n        } else {\n          //console.log(\n          //  \'add line \' +\n          //  Math.abs(op.lineNumber) +\n          //  \'(\' + op.content + \')\'\n          //);\n        }\n      });\n    };\n\n    return files;\n\n    function addFile(line) {\n      var filename = line.split(\' \')[2].replace(\'a/\', \'/sms/\');\n\n      files[filename] = {\n        hunks: [],\n        operations: []\n      };\n\n      currentFilename = filename;\n    };\n\n    function addHunk(line) {\n      if (!currentFilename) {\n        return;\n      }\n\n      currentPosition = line.split(\' \')[1].split(\',\')[0].replace(\'-\', \'\');\n      files[currentFilename].hunks.push(line);\n    };\n\n    function addDeletion(line) {\n      if (!currentFilename) {\n        return;\n      }\n\n      files[currentFilename].operations.push({\n        \'type\': \'deletion\',\n        \'lineNumber\': currentPosition\n      });\n    };\n\n    function addAddition(line) {\n      if (!currentFilename) {\n        return;\n      }\n\n      files[currentFilename].operations.push({\n        \'type\': \'addition\',\n        \'lineNumber\': currentPosition,\n        \'content\': line.replace(/^\\+/, \'\')\n      });\n\n      increment();\n    };\n\n    function increment() {\n      currentPosition++;\n    }\n\n    function decrement() {\n      currentPosition--;\n    }\n\n    return ir;\n  }\n};\n;\n\nvar UpdateUtils = {\n  apply: function uu_apply(updateContent) {\n    var ir = UnifiedDiff.parse(updateContent);\n    return this._applyIR(ir);\n  },\n\n  _applyIR: function uu_applyIR(ir) {\n    // TODO\n    // Returning an object is not really ideal since the object will\n    // will likely be passed to an other execution context and then\n    // copied.\n    // It is even worse in chrome, since a new Worker can not be\n    // spawned inside the ServiceWorker because of a platform issue.\n    // See https://code.google.com/p/chromium/issues/detail?id=31666\n    // And so the Update worker will be launched by one of the\n    // service worker controlled web page. So it will be one copy to\n    // pass the data back to the page, and then one copy to pass the\n    // data from the page to the service worker...\n    //\n    // So ideally, returning an ArrayBuffer would be more efficient\n    // in all cases. But for now, I\'m a bit lazy to define a format\n    // for it and fix all the layers of the protocol helper.\n    var rv = {};\n\n    for (var filename in ir) {\n      var operations = ir[filename].operations;\n      var content = this._getFileContent(filename);\n      rv[filename] = this._applyIRForContent(operations, content);\n    };\n\n    return rv;\n  },\n\n  _applyIRForContent: function uu_applyIRForFile(operations, content) {\n    // TODO Do some sanity checks, to see if operations applies\n    // correctly based on the content of a specific line.\n\n    var lines = content.split(\'\\n\');\n\n    operations.forEach(function onEachOperation(operation) {\n      switch (operation.type) {\n        case \'deletion\':\n          lines.splice(operation.lineNumber - 1, 1);\n          break;\n\n        case \'addition\':\n          lines.splice(operation.lineNumber - 1, 0, operation.content);\n          break;\n      }\n    });\n\n    return lines.join(\'\\n\');\n  },\n\n  _getFileContent: function uu_getFileContent(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\'GET\', url, false);\n    xhr.send();\n\n    return xhr.responseText;\n  }\n};\n\n;\n\'use strict\';\n\nvar Config = {\n  getUpdateInfos: function config_getUpdateUrl() {\n    var promise = new Promise(function(resolve, reject) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\'GET\', \'/sms/app/config.json\', true);\n      xhr.send();\n\n      xhr.onload = function() {\n        // XXX Use json format directly instead of calling JSON.parse\n        var json = JSON.parse(this.responseText);\n\n        var updateUrl = json.update.url +\n\n                        // old version\n                        json.update.channel +\n                        \'_\' +\n                        json.update.version +\n\n                        \'...\' +\n\n                        // new version\n                        json.update.channel +\n                        \'_\' +\n                        \'master\';\n\n        var updateHeaders = json.update.headers;\n\n        resolve({\n          \'url\': updateUrl,\n          \'headers\': updateHeaders\n        });\n      };\n\n      xhr.onerror = function() {\n        reject(this.status);\n      };\n    });\n\n    return promise;\n  }\n};\n\n;\n\nfunction debug(str) {\n  console.log(\'Worker: \' + str);\n  if (\'dump\' in self) {\n    dump(\'Worker: \' + str + \'\\n\');\n  }\n}\n\nvar protocol = new IPDLProtocol(\'update\');\n\nprotocol.recvCheckForUpdate = function(resolve, reject, args) {\n  var self = this;\n\n  Config.getUpdateInfos().then(\n    function onUpdateInfosSuccess(updateInfos) {\n      self._getFileContent(updateInfos).then(\n        function onFileContentSuccess(content) {\n          // XXX Ideally we would just perform a HEAD requet instead\n          // of a GET, and retrieve the Content-Length header.\n          //     But github, does not seems to allow that :(\n          //var length = this.getResponseHeader(\'Content-Length\');\n          resolve(content.length);\n        },\n\n        function onFileContentError(rv) {\n          reject(rv);\n        }\n      );\n    },\n\n    function onUpdateInfosError(rv) {\n      reject(rv);\n    }\n  );\n};\n\nprotocol.recvApplyUpdate = function(resolve, reject, args) {\n  var self = this;\n\n  Config.getUpdateInfos().then(\n    function onUpdateUrlSuccess(updateInfos) {\n      if (args.updateUrl) {\n        updateInfos = {\n          \'url\': args.updateUrl,\n          \'headers\': {}\n        };\n      }\n\n      self._getFileContent(updateInfos).then(\n        function onFileContentSuccess(content) {\n          var rv = UpdateUtils.apply(content);\n          resolve(rv);\n        },\n\n        function onFileContentError(rv) {\n          reject(rv);\n        }\n      );\n    },\n\n    function onUpdateInfosError(rv) {\n      reject(rv);\n    }\n  );\n};\n\nprotocol._getFileContent = function(infos) {\n  return new Promise(function onFileContent(resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\'GET\', infos.url, true);\n\n    for (var header in infos.headers) {\n      xhr.setRequestHeader(header, infos.headers[header]);\n    }\n\n    xhr.send();\n\n    xhr.onload = function() {\n      resolve(this.responseText);\n    };\n\n    xhr.onerror = function() {\n      reject(this.status);\n    };\n  });\n};\n\n',
                opts: { 'headers': { 'content-type': 'application/javascript' } }
            }
        }
    };